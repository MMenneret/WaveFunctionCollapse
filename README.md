# WaveFunctionCollapse

1- A quoi sert cet algorithme ?

  Le but de Wave Function Collapse est de générer un résultat semi-aléatoire (généralement une image ou texture) à partir d'une image d'entrée. Pour cela, il fonctionne selon un système de contraintes, c'est à dire de règles pré-déterminées à respecter pour générer son résultat. L'algorithme se présentant sous deux formes principales distinctes, les règles de chacune de ces formes varie légèrement, mais le principe d'adjacence va rester le même : Nous établissons quels éléments peuvent être voisins entre eux afin de pouvoir générer un résultat cohérent.   
  
  2- Quelles sont ces règles ?  
  
La meilleure manière de convevoir ce que sont ces règles d'adjacence est de prendre l'exemple du Sudoku, le processus mental nécessaire pour remplir celui-ci étant très similaire à la manière dont fonctionne notre algorithme. En effet, les règles du Sudoku nous disent qu'il nous faut remplir une grille de 9x9 cases en respectant les règles suivantes :
      -Chaque case doit contenir un chiffre entre 1 et 9 (compris)
      -Chaque bloc de 3x3 cases ne doit contenir qu'un examplaire de chaque chiffre
      -Chaque ligne horizontale et verticale de 9 cases ne doit contenir qu'un examplaire de chaque chiffre  
Si contrairement à notre résultat, une grille de Sudoku ne commence jamais en étant vide, le principe reste le même: Chaque case ne peut contenir qu'un chiffre précis, et la seule manière de déduire quel est ce chiffre est un processus d'élimination rendu possible par l'existence des règles établies ci-dessus. Pour compléter notre grille, il va donc falloir, par processus de déduction trouver les cases qui ne possèdent initialement qu'une solution, car lorsque la valeur d'une case est découverte, les possibilités de toutes les cases dans le même bloc ou sur la même ligne sont diminuées. Par exemple, si une case ne possède plus que 1 ou 4 comme valeurs possibles et que je découvre qu'une case partageant la même ligne vaut 1, notre première case ne peut plus prendre comme valeur que 4.  

3- Concrètement, comment cela fonctionne ?  

Comme précisé ci-dessus, il existe deux variantes pour cet algorithme, la première se nommant le "Simple-tiled model", et la seconde l' "Overlapping model", je vais donc traiter chacun d'eux séparément dans cette section. S'il existe des variantes de l'algorithme pouvant fonctionner en 3-dimensions, nous allons ici nous pencher sur le cas de figure le plus courant: Essayer de remplir une grille en 2-dimensions de "pixels" ou "cases".
  
  -Simple-tiled model: Comme son nom l'indique, le simple-tiled model utilise comme données d'entrée des "tiles" ou "cases" de forme carrées possédant 4 connexions pour chacune des directions cardinales, cette valeur décrivant le type de connexion qui sera présente dans la direction corresopndante. Par exemple, imaginons un ensemble de cases avec deux "routes" possibles, l'une de terre et l'autre d'eau (donc une rivière), dans cette situation, chaque case pourra avoir 3 valeurs possibles dans chaque direction: 0 s'il n'y aucun chemin dans cette direction, 1 si c'est un chemin de terre et 2 si cet une rivière. La manière d'établir une adjacence entre deux cases est donc elle aussi très intuitive: Si l'une de mes cases possède une valeur 1 dans la direction Nord, seront des voisins valides dans cette direction toutes cases donc la direction Sud possède également une valeur de 1.
  
-Overlapping model: Ce système, un peu moins évident à appréhender reste cependant assez accessible. Cette fois-ci, plutôt que de directement avoir des cases préconstruites en entrée avec des valeurs données dans chaque direction, nous allons devoir les créer nous-même à partir d'une image d'entrée. Pour cela, nous allons scanner chaque pixel de cette image et créer un échantillon de taille N (la valeur de N étant généralement 3), c'est à dire un bloc de NxN pixels ayant pour centre notre pixel. Une fois ces échantillons créés, nous devons établir quels échantillons peuvent être adjacents, c'est à dire échantillons peuvent superposés (ou "overlapped" en anglais) dans une direction donnée. Pour prendre un exemple, pour deux échantillons de 3x3 pixels, si les pixels des deux rangées supérieurs de notre premier échantillon partage exactement les mêmes couleurs avec les pixels des deux rangées inférieures du second, alons nous avons une adjacence dans la direction Nord pour le premier et Sud pour le second.
